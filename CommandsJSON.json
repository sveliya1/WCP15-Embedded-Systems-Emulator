{
  "ADC": "A1 = A1 + A2 + carryFlag ;",
  "ADD": "A1 = A1 + A2 ;",
  "ADDS": "A1 = A1 + A2 ; result = A1 ;",
  "AND": "A1 = A1 & A2 ;",
  "ANDS": "A1 = A1 & A2 ; result = A1 ;",
  "BIC": "A1 = A1 & NOT A2 ;",
  "BX": "//R15 = A1 ; \n T bit = Rn[0] ;",
  "CDP": "//(Coprocessor-specific) ;",
  "CMN": "//cpsr flags = A1 + A2 ;",
  "CMP": "result = A1 - A2",
  "EOR": "A1 = (A1 & NOT A2) | (A2 & NOT A1) ;",
  "LDC": "//Coprocessor load ;",
  "LDM": "//stack manipulation (Pop) ;",
  "LDR": "A1 = Memory[ S2_3 /8 ] ;",
  "MCR": "cA1 = rA1 {<op>cRm} ;",
  "MLA": "A1 = (Rm * Rs) + A1 ;",
  "MOV": "A1 = A2 ;",
  "MOVS": "A1 = A2 ; result = A1 ;",
  "MRC": "A1 = cA1 {<op>cRm} ;",
  "MRS": "A1 = PSR ;",
  "MSR": "PSR = Rm ;",
  "MUL": "A1 = Rm * Rs ;",
  "MVN": "A1 = 0xFFFFFFFF EOR A2 ;",
  "ORR": "A1 = A1 | A2 ;",
  "ORRS": "A1 = A1 | A2 ; result = A1 ;",
  "RSB": "A1 = A2 - A1 ;",
  "RSC": "A1 = A2 - A1 - 1 + Carry ;",
  "SBC": "A1 = A1 - A2 - 1 + Carry ;",
  "STC": "MEMORY[ ADDRESS ]= CA1 ;",
  "PUSH": "//stack manipulation (Push) ;",
  "STR": "Memory[ <ADDRESS> ] = A1 ;",
  "SUB": "A1 = A1 - A2 ;",
  "SUBS": "A1 = A1 - A2 ; result = A1 ;",
  "SWI": "OS call ;",
  "SWP": "A1 = [A1], [A1] := Rm ;",
  "TEQ": "cpsr flags = A1 EOR A2 ;",
  "TST": "result = A1 & A2 ;",
  "LSRS": "A1 = (A2 >> A3) ;",
  "LSLS": "A1 = (A2 << A3) ;",
  "BNE": "if(result != 0){\n    goto A1 ;}",
  "BEQ": "if(result == 0){ goto A1 ; }",
  "BEQ.N": "if(result == 0){ goto A1 ; }",
  "BNE.N": "if(result != 0){\n    goto A1 ;}",
  "B": "goto A1 ;",
  "BL": "goto A2 ; //TODO linking ",
  "B.N": "goto A1 ;",
  "BCS.N": "if(!(result & (1 << 31))){ goto A1 ; }"
}