

#define FLASH_START 0x00000000
#define FLASH_SIZE 0x07FFFFFF
#define RAM_START 0x1FFFF000-1
#define RAM_SIZE 0x20002FFF-RAM_START
#define AIPS_START 0x40000000
#define AIPS_SIZE 0x4007FFFF-AIPS_START


#define GPIO_START 0x400FF000 
#define GPIO_SIZE 0x400FFFFF-GPIO_START

#define PRIVATE_PERI_START 0xE0000000
#define PRIVATE_SIZE 0xE00FFFFF - PRIVATE_PERI_START

enum instructions {
	ADDS, SUBS, ANDS, EORS, ORRS, BICS, ORNS, ADCS, RSBS, SBCS, CMP, CMN, MULS, TST, LSLS, LSRS, ASRS,
	RORS, MOVS, MVN
};

uint64_t r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, sp, LR, PC, result;

uint32_t g_embedded_sys_freq = 1000000000;
uint32_t supervisor_threshold = 0.1*g_embedded_sys_freq;
std::mutex io_lock;
std::condition_variable io_cond;
std::condition_variable main_thread_io;
int show_io = 0;

/*
void io_write(uint32_t address, uint32_t value);
void clear_register(uint32_t address, uint32_t value);
void set_register(uint32_t address, uint32_t value);
void toggle_register(uint32_t address, uint32_t value);
*/
uint8_t lsb_byte;
uint32_t g_cycle_count, lsb_word;
bool N_flag, C_flag, Z_flag, V_flag;
MemoryMap* map = new MemoryMap();
RAMDevice* gpio = new RAMDevice(GPIO_START, GPIO_SIZE, ENDIAN_LITTLE);
RAMDevice* aips = new RAMDevice(AIPS_START, AIPS_SIZE, ENDIAN_LITTLE);
RAMDevice* ram = new RAMDevice(RAM_START, RAM_SIZE, ENDIAN_LITTLE);
RAMDevice* private_peri = new RAMDevice(PRIVATE_PERI_START, PRIVATE_SIZE, ENDIAN_LITTLE);

ROMDevice* flash = new ROMDevice(FLASH_START, FLASH_SIZE, ENDIAN_LITTLE);

void set_rgbled_color_to();
void supervisor();
void led_read_state();
void get_io_mutex();
uint32_t read_register(uint32_t address, uint32_t bit_value);
double get_cpu_time();
void clear_register(uint32_t address, uint32_t value);
void set_register(uint32_t address, uint32_t value);
void toggle_register(uint32_t address, uint32_t value);

void clear_register(uint32_t address, uint32_t value)
{
	uint64_t port_reg = map->read(address, Size::WORD);
	port_reg &= ~value;
	map->write(address, (uint32_t)port_reg, Size::WORD);
}
void set_register(uint32_t address, uint32_t value)
{
	uint64_t port_reg = map->read(address, Size::WORD);
	port_reg |= value;
	map->write(address, (uint32_t)port_reg, Size::WORD);
}

void toggle_register(uint32_t address, uint32_t value)
{
	uint64_t port_reg = map->read(address, Size::WORD);
	port_reg ^= value;
	map->write(address, (uint32_t)port_reg, Size::WORD);
}

double get_cpu_time() {
	FILETIME a, b, c, d;
	if (GetProcessTimes(GetCurrentProcess(), &a, &b, &c, &d) != 0) {
		//  Returns total user time.
		//  Can be tweaked to include kernel times as well.
		return
			(double)(d.dwLowDateTime |
			((unsigned long long)d.dwHighDateTime << 32)) * 0.0000001;
	}
	else {
		//  Handle error
		return 0;
	}
}

uint32_t read_register(uint32_t address, uint32_t bit_value)
{
	uint32_t register_value = map->read(address, Size::WORD);
	register_value &= ((1uL << bit_value));
	register_value = (register_value >> bit_value);
	return register_value;
}

void get_io_mutex() {

	//std::cout << "Show IO: " << show_io << std::endl;
	std::unique_lock<std::mutex> locker(io_lock);
	main_thread_io.wait(locker, []() { return !show_io; });
	//std::cout << "Show IO: " << show_io << std::endl;
	show_io = 1;
	io_cond.notify_one();
	locker.unlock();

}

void led_read_state()
{

	while (1) {
		std::unique_lock<std::mutex> locker(io_lock);
		io_cond.wait(locker, []() { return show_io; }); //Still can have spurious wakeups
		//Read the LED values
		//std::cout << "Show IO: " << show_io << std::endl;
		uint32_t redled_value = read_register(0x400FF040, 18) << 2; //11 /
		uint32_t greenled_value = read_register(0x400FF040, 19) << 1; //12
		uint32_t blueled_value = read_register(0x400FF0c0, 1); //8
		//std::cout << redled_value << "\n" << greenled_value << "\n" << blueled_value << "\n";
		uint32_t result = redled_value + greenled_value + blueled_value;
		switch (result)
		{
		case 0:
			std::cout << "LED is WHITE\n";
			break;
		case 1: //001
			std::cout << "LED is YELLOW\n";
			break;
		case 2:
			std::cout << "LED is MAGENTA\n";
			break;
		case 3:
			std::cout << "LED is RED\n";
			break;
		case 4:
			std::cout << "LED is CYAN\n";
			break;

		case 5:
			std::cout << "LED is GREEN\n";
			break;

		case 6:
			std::cout << "LED is BLUE\n";
			break;
		case 7:
			std::cout << "LED is BLACK\n";
			break;
		default:
			std::cout << "Switch statement is broken...\n";
			break;
		}
		show_io = 0;
		locker.unlock();
		main_thread_io.notify_one();
	}
}

void supervisor() {

	if (g_cycle_count < supervisor_threshold)
		return;

	static double previous_CPU_time = 0;
	long double embedded_sys_CPU_time = (long double)g_cycle_count / g_embedded_sys_freq; // seconds
	//double wall_clock_time = get_wall_time();
	//std::cout << "Wall Clock Time: " << wall_clock_time << std::endl;
	double host_CPU_time = get_cpu_time();
	double CPU_time_bt_call = host_CPU_time - previous_CPU_time;
	double sleep_time = embedded_sys_CPU_time - CPU_time_bt_call;
	if (sleep_time > 0) {
		//std::cout << "Sleep Time: " << sleep_time << std::endl;
		Sleep((sleep_time) * 1000);
	}
	previous_CPU_time = host_CPU_time;
	std::cout << "Sleep Time: " << sleep_time << std::endl;
	//std::cout << "Host CPU TIME: " << CPU_time_bt_call << std::endl;
	//std::cout << "Embedded CPU Time: " << embedded_sys_CPU_time << std::endl;
	//std::cout << "Cycle Count: " << g_cycle_count << std::endl;
	//std::cout << "Embedded System Freq: " << g_embedded_sys_freq << std::endl;
	g_cycle_count = 0;

}

void main()
{

	std::cout << "Hello" << std::endl;
	map->addDevice(flash);
	map->addDevice(ram);
	map->addDevice(aips);
	map->addDevice(gpio);
	map->addDevice(private_peri);

	//burn_flash_to_mem(flash);
	std::cout << "Memory Allocate is good" << std::endl;
	//SP = init_sp();
_reset_init();